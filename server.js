// server.js (final: natural chat + recap fix + full context + valid Gemini API)
import express from "express";
import bodyParser from "body-parser";
import pkg from "pg";
import dotenv from "dotenv";
import { GoogleGenerativeAI } from "@google/generative-ai";
import path from "path";
import { fileURLToPath } from "url";

dotenv.config();

const app = express();
app.use(bodyParser.json());

// ===== path helpers =====
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ===== Postgres setup =====
const { Pool } = pkg;
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

// ===== Gemini setup =====
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// ===== init tables =====
async function initTables() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS books (
      id SERIAL PRIMARY KEY,
      name TEXT NOT NULL,
      author TEXT NOT NULL,
      category TEXT,
      position TEXT,
      created_at TIMESTAMP DEFAULT NOW()
    )
  `);

  await pool.query(`
    CREATE TABLE IF NOT EXISTS conversations (
      id SERIAL PRIMARY KEY,
      role TEXT NOT NULL,
      message TEXT NOT NULL,
      created_at TIMESTAMP DEFAULT NOW()
    )
  `);
}
await initTables();

// seed if needed
import("./seedBooks.js").catch(()=>{/* ignore if missing */});

// ===== helpers =====
function extractFirstJson(text) {
  if (!text || typeof text !== "string") return null;
  const match = text.match(/\{[\s\S]*\}/);
  if (!match) return null;
  try {
    return JSON.parse(match[0]);
  } catch {
    return null;
  }
}

async function assignPosition(category) {
  if (!category) return "X?";
  const letter = category.trim()[0]?.toUpperCase() || "X";
  const res = await pool.query("SELECT COUNT(*) FROM books WHERE category = $1", [category]);
  const count = parseInt(res.rows[0].count || "0", 10);
  const shelf = Math.floor(count / 15) + 1;
  return `${letter}${shelf}`;
}

async function inferCategory(bookName, author) {
  const model = genAI.getGenerativeModel({
    model: "gemini-2.5-flash",
    tools: [{ type: "google_search_retrieval" }] // Cho ph√©p Gemini tra web khi c·∫ßn
  });

  // Danh m·ª•c c·ªë ƒë·ªãnh c·ªßa th∆∞ vi·ªán
  const allowedCategories = [
    "VƒÉn h·ªçc",
    "L·ªãch s·ª≠",
    "C√¥ng ngh·ªá",
    "Khoa h·ªçc",
    "T√¢m l√Ω",
    "Gi√°o d·ª•c",
    "Kinh t·∫ø",
    "VƒÉn ho√°",
    "Ch√≠nh tr·ªã",
    "Thi·∫øu nhi",
    "T√¥n gi√°o",
    "X√£ h·ªôi"
  ];

  const prompt = `
B·∫°n l√† th·ªß th∆∞ th√¥ng minh c·ªßa th∆∞ vi·ªán.
D·ª±a v√†o th√¥ng tin c√≥ th·ªÉ t√¨m th·∫•y tr√™n web n·∫øu c·∫ßn, h√£y x√°c ƒë·ªãnh th·ªÉ lo·∫°i ph√π h·ª£p nh·∫•t cho cu·ªën s√°ch.
Ph·∫£i ch·ªçn m·ªôt trong c√°c th·ªÉ lo·∫°i sau: ${allowedCategories.join(", ")}.

T√™n s√°ch: "${bookName}"
T√°c gi·∫£: "${author}"

Tr·∫£ v·ªÅ ƒë√∫ng m·ªôt JSON duy nh·∫•t: {"category": "Th·ªÉ lo·∫°i t·ª´ danh s√°ch tr√™n"}
N·∫øu kh√¥ng ch·∫Øc ch·∫Øn, tr·∫£ {"category": "Ch∆∞a r√µ"}.
`;

  try {
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }]
    });

    const raw = result.response.text();
    const parsed = extractFirstJson(raw);

    // N·∫øu Gemini tr·∫£ v·ªÅ h·ª£p l·ªá v√† kh·ªõp danh s√°ch
    if (parsed && parsed.category) {
      const found = allowedCategories.find(c =>
        parsed.category.toLowerCase().includes(c.toLowerCase())
      );
      if (found) return found;
      if (parsed.category.toLowerCase().includes("ch∆∞a r√µ")) return "Ch∆∞a r√µ";
    }

    // N·∫øu kh√¥ng c√≥ ho·∫∑c kh√¥ng h·ª£p l·ªá ‚Üí fallback t·ª± suy lu·∫≠n
    const titleLower = bookName.toLowerCase();
    if (/(python|program|code|data|ai|machine|k·ªπ thu·∫≠t|c√¥ng ngh·ªá)/i.test(titleLower)) return "C√¥ng ngh·ªá";
    if (/(l·ªãch s·ª≠|history|war|chi·∫øn tranh|ƒë·∫∑ng th√πy tr√¢m|tr·∫ßn h∆∞ng ƒë·∫°o)/i.test(titleLower)) return "L·ªãch s·ª≠";
    if (/(ti·ªÉu thuy·∫øt|truy·ªán|novel|k√Ω|th∆°|vƒÉn h·ªçc|poem|fiction)/i.test(titleLower)) return "VƒÉn h·ªçc";
    if (/(t√¢m l√Ω|psychology|c·∫£m x√∫c|h√†nh vi)/i.test(titleLower)) return "T√¢m l√Ω";
    if (/(gi√°o d·ª•c|education|h·ªçc t·∫≠p)/i.test(titleLower)) return "Gi√°o d·ª•c";
    if (/(kinh t·∫ø|economy|business|th∆∞∆°ng m·∫°i)/i.test(titleLower)) return "Kinh t·∫ø";
    if (/(ch√≠nh tr·ªã|politic|x√£ h·ªôi|culture|vƒÉn ho√°|religion|t√¥n gi√°o|society)/i.test(titleLower)) return "X√£ h·ªôi";
    return "Ch∆∞a r√µ";
  } catch (e) {
    console.error("‚ö†Ô∏è inferCategory error:", e);
    return "Ch∆∞a r√µ";
  }
}


async function askGeminiToChoose(message, books, conversationContext = "") {
  const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

  const prompt = `
B·∫°n l√† tr·ª£ l√Ω th∆∞ vi·ªán. D·ª±a tr√™n ƒëo·∫°n h·ªôi tho·∫°i g·∫ßn ƒë√¢y:
${conversationContext}

Ng∆∞·ªùi d√πng v·ª´a n√≥i: "${message}"

Danh s√°ch s√°ch: ${JSON.stringify(books, null, 2)}

Tr·∫£ v·ªÅ JSON duy nh·∫•t:
{
 "title": "T√™n s√°ch EXACT t·ª´ DB",
 "author": "T√°c gi·∫£ EXACT t·ª´ DB",
 "category": "Th·ªÉ lo·∫°i EXACT t·ª´ DB",
 "location": "V·ªã tr√≠ EXACT t·ª´ DB",
 "reason": "Gi·∫£i th√≠ch ng·∫Øn (1-2 c√¢u)"
}
`;

  try {
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }]
    });
    const raw = result.response.text();
    const parsed = extractFirstJson(raw);
    return parsed;
  } catch (e) {
    console.error("‚ö†Ô∏è askGeminiToChoose error:", e);
    return null;
  }
}

async function askGeminiForRecap(bookTitle, author) {
  const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

  const prompt = `
B·∫°n l√† m·ªôt tr·ª£ l√Ω t√≥m t·∫Øt s√°ch chuy√™n nghi·ªáp.
T√≥m t·∫Øt ng·∫Øn (100-200 t·ª´) n·ªôi dung, ch·ªß ƒë·ªÅ v√† ƒë·ªëi t∆∞·ª£ng ng∆∞·ªùi ƒë·ªçc c·ªßa cu·ªën:
- T√™n: "${bookTitle}"
- T√°c gi·∫£: "${author}"

Tr·∫£ v·ªÅ JSON duy nh·∫•t:
{"title":"${bookTitle}", "author":"${author}", "recap":"T√≥m t·∫Øt ng·∫Øn g·ªçn kh√¥ng qu√° 200 t·ª´"}
`;

  try {
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }]
    });
    const raw = result.response.text();
    const parsed = extractFirstJson(raw);
    return parsed;
  } catch (e) {
    console.error("‚ö†Ô∏è askGeminiForRecap error:", e);
    return null;
  }
}

// ===== Chat t·ª± nhi√™n c√≥ tra web =====
async function chatWithGeminiFreeform(message, context = "") {
  const model = genAI.getGenerativeModel({
    model: "gemini-2.5-flash",
    tools: [{ type: "google_search_retrieval" }]
  });

  const prompt = `
B·∫°n l√† tr·ª£ l√Ω AI th√¢n thi·ªán, th√¥ng minh, c√≥ th·ªÉ tra c·ª©u th√¥ng tin tr√™n web khi c·∫ßn.
Ng·ªØ c·∫£nh tr∆∞·ªõc ƒë√≥:
${context}

Ng∆∞·ªùi d√πng: "${message}"

H√£y tr·∫£ l·ªùi t·ª± nhi√™n, d·ªÖ hi·ªÉu (b·∫±ng ti·∫øng Vi·ªát), s·ª≠ d·ª•ng th√¥ng tin ch√≠nh x√°c n·∫øu c·∫ßn tra web.
`;

  try {
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }]
    });
    const text = result.response.text();
    return text || "‚ö†Ô∏è Kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ Gemini.";
  } catch (e) {
    console.error("‚ö†Ô∏è chatWithGeminiFreeform error:", e);
    return "‚ö†Ô∏è Xin l·ªói, m√¨nh ch∆∞a th·ªÉ ph·∫£n h·ªìi l√∫c n√†y.";
  }
}

// ===== Serve index.html =====
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "index.html"));
});

// ===== /chat endpoint =====
app.post("/chat", async (req, res) => {
  const { message } = req.body;
  if (!message) return res.status(400).json({ error: "Thi·∫øu 'message'" });

  try {
    await pool.query("INSERT INTO conversations (role, message) VALUES ($1, $2)", ["user", message]);
    let reply = "";
    const lower = message.toLowerCase();

    // ADD BOOK
    if (lower.startsWith("add book")) {
      const match = message.match(/bn:\s*([^;]+);\s*at:\s*(.+)/i);
      if (!match) reply = "‚ùå Sai c√∫ ph√°p. D√πng: add book: bn: T√™n s√°ch; at: T√°c gi·∫£";
      else {
        const bookName = match[1].trim();
        const author = match[2].trim();
        const category = await inferCategory(bookName, author);
        const position = await assignPosition(category);
        await pool.query(
          "INSERT INTO books (name, author, category, position) VALUES ($1,$2,$3,$4)",
          [bookName, author, category, position]
        );
        reply = `‚úÖ ƒê√£ th√™m s√°ch: "${bookName}" (${author})\nTh·ªÉ lo·∫°i: ${category}\nV·ªã tr√≠: ${position}`;
      }
    }

    // DELETE BOOK
    else if (lower.startsWith("delete book")) {
      const match = message.match(/bn:\s*([^;]+);\s*at:\s*(.+)/i);
      if (!match) reply = "‚ùå Sai c√∫ ph√°p. D√πng: delete book: bn: T√™n s√°ch; at: T√°c gi·∫£";
      else {
        const bookName = match[1].trim();
        const author = match[2].trim();
        const result = await pool.query("DELETE FROM books WHERE name=$1 AND author=$2 RETURNING *", [bookName, author]);
        reply = result.rowCount ? `üóëÔ∏è ƒê√£ xo√° s√°ch "${bookName}" c·ªßa ${author}` : `‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y s√°ch "${bookName}" c·ªßa ${author}`;
      }
    }

    // V·ªä TR√ç
    else if (/\bv·ªã tr√≠\s+[A-Z]\d+\b/i.test(lower)) {
      const m = lower.match(/\bv·ªã tr√≠\s+([A-Z]\d+)\b/i);
      const pos = m ? m[1].toUpperCase() : null;
      if (!pos) reply = "‚ö†Ô∏è H√£y nh·∫≠p v·ªã tr√≠ theo d·∫°ng v√≠ d·ª•: 'v·ªã tr√≠ B2 l√† quy·ªÉn g√¨'";
      else {
        const { rows } = await pool.query("SELECT name, author, category FROM books WHERE position=$1 LIMIT 1", [pos]);
        reply = rows.length
          ? `üìö ·ªû v·ªã tr√≠ ${pos}: "${rows[0].name}" (${rows[0].author})\nTh·ªÉ lo·∫°i: ${rows[0].category || "Ch∆∞a r√µ"}`
          : `üì≠ Kh√¥ng c√≥ s√°ch ·ªü v·ªã tr√≠ ${pos}.`;
      }
    }

    // RECAP
    else if (/\b(t√≥m t·∫Øt|recap|summary)\b/i.test(lower)) {
      let guess = message.replace(/["'‚Äò‚Äô‚Äú‚Äù]/g, "").toLowerCase();
      guess = guess.replace(/\b(recape?|t√≥m t·∫Øt|summary|gi√∫p|cu·ªën|s√°ch|h√£y|n·ªôi dung|cho t√¥i|v·ªÅ|ƒëi)\b/g, "").trim();

      let target = null;
      const q = await pool.query(
        `SELECT name, author, category, position FROM books 
         WHERE LOWER(name) LIKE $1 OR LOWER(author) LIKE $1 LIMIT 1`,
        [`%${guess}%`]
      );
      if (q.rows.length) target = q.rows[0];

      if (!target) {
        const all = await pool.query("SELECT name, author, category, position FROM books");
        for (const b of all.rows) {
          if (message.toLowerCase().includes(b.name.toLowerCase())) { target = b; break; }
        }
      }

      if (!target) reply = "‚ö†Ô∏è M√¨nh ch∆∞a r√µ b·∫°n mu·ªën t√≥m t·∫Øt quy·ªÉn n√†o. H√£y n√≥i t√™n s√°ch c·ª• th·ªÉ nh√©.";
      else {
        const recap = await askGeminiForRecap(target.name, target.author);
        reply = recap?.recap
          ? `üìñ "${target.name}" (${target.author})\nTh·ªÉ lo·∫°i: ${target.category || "Ch∆∞a r√µ"}, V·ªã tr√≠: ${target.position}\n\nüìù ${recap.recap}`
          : `‚ö†Ô∏è Kh√¥ng t√≥m t·∫Øt ƒë∆∞·ª£c l√∫c n√†y.`;
      }
    }

    // SEARCH ho·∫∑c CHAT t·ª± nhi√™n
    else {
      const { rows: books } = await pool.query("SELECT name, author, category, position FROM books");
      const histRes = await pool.query("SELECT role, message FROM conversations ORDER BY id DESC LIMIT 6");
      const recent = histRes.rows.reverse().map(r => `${r.role === "user" ? "Ng∆∞·ªùi d√πng" : "Tr·ª£ l√Ω"}: ${r.message}`).join("\n");

      const keywords = message.toLowerCase();
      const directMatch = books.filter(b =>
        (b.name && b.name.toLowerCase().includes(keywords)) ||
        (b.author && b.author.toLowerCase().includes(keywords)) ||
        (b.category && b.category.toLowerCase().includes(keywords))
      );

      if (!books.length || (!directMatch.length && /th·ªùi ti·∫øt|ai l√†|l√† g√¨|·ªü ƒë√¢u|bao nhi√™u|t·∫°i sao|nh∆∞ th·∫ø n√†o/i.test(message))) {
        reply = await chatWithGeminiFreeform(message, recent);
      } else {
        let chosen = null;
        if (directMatch.length === 1) {
          chosen = directMatch[0];
          reply = `üìö G·ª£i √Ω: "${chosen.name}" (${chosen.author})\nTh·ªÉ lo·∫°i: ${chosen.category || "Ch∆∞a r√µ"}, V·ªã tr√≠: ${chosen.position}`;
        } else {
          const pick = await askGeminiToChoose(message, directMatch.length ? directMatch : books, recent);
          if (pick && pick.title) {
            const rec = (directMatch.length ? directMatch : books).find(b => b.name === pick.title) || books[0];
            reply = `üìö G·ª£i √Ω: "${rec.name}" (${rec.author})\nTh·ªÉ lo·∫°i: ${rec.category || "Ch∆∞a r√µ"}, V·ªã tr√≠: ${rec.position}\nüí° ${pick.reason || ""}`;
          } else {
            reply = await chatWithGeminiFreeform(message, recent);
          }
        }
      }
    }

    await pool.query("INSERT INTO conversations (role, message) VALUES ($1, $2)", ["assistant", reply]);
    res.json({ reply });
  } catch (err) {
    console.error("‚ùå Chat error:", err);
    res.status(500).json({ error: err.message });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`‚úÖ Server ƒëang ch·∫°y tr√™n c·ªïng ${PORT}`));
